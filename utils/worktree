#!/bin/sh

source $HOME/.dotfiles/utils/common

wtnew()
{
    if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        echo "error: not inside a git working tree"
        return 1
    fi

    local root
    root=$(git worktree list | head -1 | awk '{print $1}')

    local parent
    parent=$(dirname "$root")

    local name
    name=$(randname)

    local branch
    branch="$(whoami)/${name}"

    # resolve default branch from remote rather than relying on
    # what's checked out in the main worktree
    local main_branch
    main_branch=$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@')

    git worktree add -b "$branch" "${parent}/${name}" "$main_branch"

    cd "${parent}/${name}"
}

wtdestroy()
{
    if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        echo "error: not inside a git working tree"
        return 1
    fi

    local selected
    selected=$(git worktree list | tail -n +2 | fzf --prompt="select worktree to destroy: ")

    if [ -z "$selected" ]; then
        echo "no worktree selected"
        return 1
    fi

    local wt_path
    wt_path=$(echo "$selected" | awk '{print $1}')

    local wt_branch
    wt_branch=$(echo "$selected" | sed 's/.*\[//;s/\]//')

    # if we're inside the worktree being deleted, move to main first
    local main_wt
    main_wt=$(git worktree list | head -1 | awk '{print $1}')

    if [ "$(pwd)" = "$wt_path" ] || echo "$(pwd)" | grep -q "^${wt_path}/"; then
        cd "$main_wt"
    fi

    echo "removing worktree: $wt_path"
    git worktree remove "$wt_path" || return 1

    echo "deleting branch: $wt_branch"
    if ! git branch -d "$wt_branch" 2>/dev/null; then
        echo "warning: branch '$wt_branch' is not fully merged"
        printf "force delete? [y/N] "
        read -r confirm
        if [ "$confirm" = "y" ] || [ "$confirm" = "Y" ]; then
            git branch -D "$wt_branch"
        else
            echo "branch kept"
        fi
    fi
}

wtswitch()
{
    if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        echo "error: not inside a git working tree"
        return 1
    fi

    local selected
    if [ -n "$1" ]; then
        selected=$(git worktree list | fzf --filter="$1" | head -1)
    else
        selected=$(git worktree list | fzf --prompt="switch to worktree: ")
    fi

    if [ -z "$selected" ]; then
        return 1
    fi

    _WT_PREV="$(git rev-parse --show-toplevel)"
    cd "$(echo "$selected" | awk '{print $1}')"
}

wtroot()
{
    if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        echo "error: not inside a git working tree"
        return 1
    fi

    cd "$(git rev-parse --show-toplevel)"
}

wttoggle()
{
    if [ -z "$_WT_PREV" ]; then
        echo "error: no previous worktree to toggle to"
        return 1
    fi

    local current
    current="$(git rev-parse --show-toplevel)"

    cd "$_WT_PREV"
    _WT_PREV="$current"
}

wtprunable()
{
    if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        echo "error: not inside a git working tree"
        return 1
    fi

    local main_branch
    main_branch=$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@')

    local prunable=""

    while read -r line; do
        local wt_path wt_branch
        wt_path=$(echo "$line" | awk '{print $1}')
        wt_branch=$(echo "$line" | sed 's/.*\[//;s/\]//')

        # skip if branch has unmerged commits
        if ! git merge-base --is-ancestor "$wt_branch" "origin/$main_branch" 2>/dev/null; then
            continue
        fi

        # skip if there are untracked files
        if [ -n "$(git -C "$wt_path" ls-files --others --exclude-standard)" ]; then
            continue
        fi

        echo "$line"
        prunable=1
    done < <(git worktree list | tail -n +2)

    if [ -z "$prunable" ]; then
        echo "no prunable worktrees"
    fi
}

alias wtl='git worktree list'
alias wtn='wtnew'
alias wtd='wtdestroy'
alias wts='wtswitch'
alias wtt='wttoggle'
alias wtm='wtswitch main'
